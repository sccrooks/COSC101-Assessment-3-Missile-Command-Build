/* autogenerated by Processing revision 1292 on 2023-06-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

//******************************************************************************
//
//  COSC101 Assignment 1: Missile Command
//
//  Authors: Scott Crooks, Andrew McKenzie, Robert Preston
//  
//  Usage:
//
//  Addition Information: Check readme.md file
//
//******************************************************************************




// Debug settings
boolean debugMode;     // Is debug mode enabled?
boolean cheatsEnabled; // Are cheats enabled?
boolean gameLaunching; // Is the game launch in progress? Used for launch processes

// State manager
StateManager stateManager; // Global statemanagement system. Reference this when switching state/menu

// Classes
Content content;                           // Content system, use this for loading files from external directories
Time time;                                 // Time class, used for tracking time and deltaTime
Reticle reticle;                           // Reticle class, used to display player reticle
Environment environment;                   // Environment class, used as the backdrop to the game and controls displaying bases
Cannon cannon;                             // Cannon class, used to draw and control the defence cannon
HighscoreLeaderboard highscoreLeaderboard; // Highscore display, used for displaying highscores on mainmenu and Gameover menu
GameController gameController;             // Gamecontroller controls actual game functionality. E.g. Score and level

//******************************************************************************
//  Summary: In-built processing function that is called once on startup
//           We initialize the project and global classes here.
//******************************************************************************
public void setup() {
  gameLaunching = true;
  
  // Resolution 16:9 @ 30fps
  /* size commented out by preprocessor */;
  frameRate(30);
  
  // Initialize classes
  content = new Content();
  time = new Time();
  reticle = new Reticle();
  environment = new Environment();
  cannon = new Cannon();
  highscoreLeaderboard = new HighscoreLeaderboard();
  gameController = new GameController();
  
  // Initialize state manager last as  this will start the game
  stateManager = new StateManager();
  
  // Game is no longer launching so set this to false
  gameLaunching = false;
}

//******************************************************************************
//  Summary: In-built processing function that is called once every frame
//           If a system MUST be called every frame we put it in this
//           gobal method. Otherwise we call statemanager.run() to 
//           run state specific logic each frame.
//******************************************************************************
public void draw() {
  // We need to calculate the delta time once every frame or else
  // our delta time will fall out of synce with actual time. Thus,
  // we have put it in global draw call.
  time.calcDeltaTime(); 
  
  // If the game is in debug mode, print the following stats to console.
  if (debugMode) {
    println("DELTA TIME: " + time.getDeltaTimeSeconds() + " (seconds)");
    println("CURRENTSTATE: " + stateManager.currentState.getClass().getSimpleName());
  }
  
  // We draw the environment every frame for every state so that we
  // have a nice backdrop for menus.
  environment.draw();
  
  // Perform state specific logic every frame
  stateManager.run();
  
  // Draw display after performing state logic
  stateManager.drawDisplay();
}

//******************************************************************************
//  Summary: In-built processing function that is called once whenever
//           a key is pressed. For us we delegate this event to our
//           state manager as inputs vary between states.
//******************************************************************************
public void keyPressed() {
  stateManager.handleInput();
}

//******************************************************************************
//  Summary: Performs exit functionality
//******************************************************************************
public void exit() {
  // Save user preferences in case they have veen changed
  content.saveUserPreferences();
  
  // Perform normal exit logic
  super.exit();
}
//******************************************************************************
//  Authors: Andrew McKenzie
//
//  Usage: Draws cannon and gets the cannon to follow the reticle
//  Also controls the amount of ammo the player has remaining
//******************************************************************************
public class Cannon {

  private final PVector position; // The position of the cannon base

  private int ammo;       // The total ammo available to the player
  private PVector endPos; // XY position at the tip of the cannon
  private int[] rgb;      // Colour of the cannon

  //******************************************************************************
  //  Summary: Constructor setting the center point on x-axis and initilizing 
  //         the bases
  //******************************************************************************
  public Cannon() {
    // Base x and y values for the cannon
    this.position = new PVector(width/2, height-55);
    this.endPos = new PVector();
    this.rgb = new int[3];
    this.rgb[0] = 183;
    this.rgb[1] = 165;
    this.rgb[2] = 120;
  }

  //******************************************************************************
  //  Summary: Draws the cannon using the current reticle position
  //           mapped to the cannon size
  //******************************************************************************
  public void drawCannon() {

    // Taking the reticle PVector position and storing the x and y values
    PVector reticlePos = reticle.getReticlePos();
    float reticleXPos = reticlePos.x + reticle.transform.width / 2;
    float reticleYPos = height - reticlePos.y;

    // Mapping the distance between the cannon and
    // reticle to an appropriate cannon size
    endPos.x = map(reticleXPos, 0, width, position.x-30, position.x+30);
    endPos.y = map(reticleYPos, 0, height-30, position.y, height-65);

    strokeWeight(10);
    stroke(rgb[0], rgb[1], rgb[2]);

    // Draws the cannon
    line(position.x, position.y, endPos.x, endPos.y);

    noStroke();
  }
  
  //******************************************************************************
  //  Summary: Fires the cannon
  //******************************************************************************
  public void fireCannon() {
    if (isAmmoRemaining()) {
      gameController.defenceMissiles.add(new DefenceMissile());
      content.playSound("CannonFire");
      removeAmmo(1);
    }
  }

  //******************************************************************************
  //  Summary: Getter for the end of the cannons position
  //  Return: x coordinate for the end of the cannon
  //******************************************************************************
  public PVector getEndPosition() {
    return endPos;
  }

  //******************************************************************************
  //  Summary: To add ammuntion for the player
  //  Params: ammo: Amount of ammo to add
  //******************************************************************************
  public void addAmmo(int ammo) {
    ammo += ammo;
  }
  
  //******************************************************************************
  //  Summary: Removes requested amount of ammo
  //  Params: ammo: Amount of ammo to remove
  //******************************************************************************
  public void removeAmmo(int ammo) {
    if (this.ammo - ammo < 0)
      this.ammo = 0;
    else
      this.ammo-= ammo;
  }

  //******************************************************************************
  //  Summary: Getter for ammo
  //  Return: int representing the number of ammo left
  //******************************************************************************
  public int getAmmo() {
    return ammo;
  }

  //******************************************************************************
  //  Summary: Setter for ammo
  //  Params: numAmmo: what to set ammo to
  //******************************************************************************
  public void setAmmo(int numAmmo) {
    ammo = numAmmo;
  }
  
  //******************************************************************************
  //  Summary: Is there any ammo remaining/available
  //  Return: boolean
  //******************************************************************************
  public boolean isAmmoRemaining() {
    return (ammo > 0);
  }
  
  //******************************************************************************
  //  Summary: Setter for the cannon rgb
  //******************************************************************************
  public void setRGB(int[] rgb) {
    this.rgb = rgb;
  }
}


//********************************************************************************
//  Authors: Andrew McKenzie
//  (Modified form of Scott Crooks Enemies class)
//
//  Usage: Defence missile launching
//********************************************************************************
public class DefenceMissile {

  public Transform transform; // Physical missile shape

  private float speed; // Controls the speed of the missile
  private int colour; // Colour for the defense missile

  private PVector launchPos; // Cannon position when the missile was launched
  private PVector targetPos; // Reticle position when the missile was launched
  private PVector path; // Path for the missile to travel

  private float targetX; // Adjust reticle x position for center of reticle
  private float targetY; // Y position of reticle at time of missile launch

  private Trail trail; // Even the defence missiles have trails
  private int trailCounter; // I'll just do a simple one.

  //******************************************************************************
  //  Summary: Constructor for the defence missile
  //  Params: None
  //******************************************************************************
  public DefenceMissile() {

    // PVector for the launch position adjusted for size of rectangle
    launchPos = new PVector(cannon.getEndPosition().x-5,
      cannon.getEndPosition().y-5);

    // Target position of reticle at time of launching
    targetPos = reticle.getReticlePos();
    targetY = targetPos.y;
    targetX = targetPos.x + reticle.transform.width / 2;

    // Creating Transform
    transform = new Transform(launchPos, new PVector(5, 5));

    // PVector for the path between both points
    path = new PVector(targetX - launchPos.x, targetY - launchPos.y);

    trail = gameController.NewTrail();

    speed = 200;
    colour = 255;
  }

  //******************************************************************************
  //  Summary: Draws the missile
  //******************************************************************************
  public void draw() {
    fill(colour);
    rect(transform.position.x, transform.position.y,
      transform.width, transform.height);
  }

  //******************************************************************************
  //  Summary: Updates the position of the missile along the path to its target
  //******************************************************************************
  public void run() {
    // Calculate path of missile
    path.normalize();
    path.mult(speed);
    transform.position.x += path.x * time.getDeltaTimeSeconds();
    transform.position.y += path.y * time.getDeltaTimeSeconds();

    // Calculate trail
    trailCounter++;
    if (trailCounter > 2) {

      PVector ps = new PVector(transform.position.x + transform.width / 2, transform.position.y + transform.height / 2);
      trail.addSegment(ps);
      trailCounter = 0;
    }
  }

  //******************************************************************************
  //  Summary: call this when you destroy the defence missile.
  //******************************************************************************
  public void destroy() {
    trail.destroyed = true;
  }

  //******************************************************************************
  //  Summary: Method to check if the missile has reach it's target
  //  Return: boolean - true if missile has reached target otherwise false
  //******************************************************************************
  public boolean onTarget() {
    float reticleTargetX = abs(transform.position.x - targetX);
    float reticleTargetY = abs(transform.position.y - targetY);
    boolean onTarget = ((reticleTargetY <= 5) && (reticleTargetX <= 4));
    return onTarget;
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Manages content/data loading and saving.
//******************************************************************************
public class Content {

  // Directories
  private final String dataDir = "data/";
  private final String fontDir = "data/fonts/";
  private final String soundDir = "data/sounds/";
  private final String levelDir = "data/levels/";
  private final String savedataDir = "data/savedata/";

  // Fonts
  public final PFont upheavtt;         // Custom font
  public final float fontSizeTitle;    // Title font size
  public final float fontSizeSubtitle; // Subtitle font size

  // Sounds
  private final HashMap<String, SoundFile> sounds = new HashMap<String, SoundFile>();

  // Save data
  private List<Score> highscores = new ArrayList<Score>();
  public final int maxNumOfHighscores = 6;

  // Level data
  public List<Level> levels;

  //****************************************************************************
  //  Summary: Constructor; we load all game content when this constructor is
  //           called.
  //****************************************************************************
  public Content() {
    println("Loading content...");

    // Load font settings
    println("Loading font settings...");
    fontSizeTitle = 48;
    fontSizeSubtitle = 24;
    upheavtt = createFont(fontDir + "upheavtt.ttf", fontSizeTitle); // Import custom font
    textFont(upheavtt); // Set font to new font
    println("Loaded font settings!");

    // Load Sounds
    println("Loading sounds...");
    sounds.put("ReticleMove", new SoundFile(main.this, soundDir + "ReticleMove.mp3"));
    sounds.put("BaseCollapse", new SoundFile(main.this, soundDir + "BaseCollapse.mp3"));
    sounds.put("CannonFire", new SoundFile(main.this, soundDir + "CannonFire.mp3"));
    sounds.put("flakExplosion", new SoundFile(main.this, soundDir + "flakExplosion.mp3"));
    println("Loaded sounds!");

    // Load Data
    loadHighscores();
    loadLevelData();
    loadUserPreferences();

    println("Content loaded!");
  }

  //****************************************************************************
  //  Summary: Plays requested audio clip from sounds hashmap
  //  Params: name: Name of requested audio clip
  //****************************************************************************
  public void playSound(String name) {
    try {
      sounds.get(name).play();
    }
    catch(Exception e) {
      println("Sound not found!");
    }
  }

  //****************************************************************************
  //  Summary: Load highscores from savedata/highscores.json
  //****************************************************************************
  public void loadHighscores() {
    try {
      println("Loading highscores...");

      // Load highscore Json File
      JSONArray scores = loadJSONArray(savedataDir + "highscores.json");

      // For each JSON object in file add to highscore list
      for (int i = 0; i < scores.size(); i++) {
        JSONObject score = scores.getJSONObject(i);
        highscores.add(new Score(score.getString("name"), score.getInt("score")));
      }

      // Fill out any remaining highscore slots with empty values
      while (highscores.size() < maxNumOfHighscores) {
        highscores.add(new Score());
      }
      println("Highscores loaded!");
    }
    catch(Exception e) {
      println("Something went wrong! Failed to load highscores");
    }
  }

  //****************************************************************************
  //  Summary: Save highscores to savedata/highscores.json
  //****************************************************************************
  public void saveHighscores() {
    try {
      // Create JSONArray
      JSONArray scores = new JSONArray();

      // For each highscore in list write to JSONArray
      for (int i = 0; i < highscores.size() || i < maxNumOfHighscores; i++) {
        JSONObject score = new JSONObject();
        score.setString("name", highscores.get(i).name);  // Save Name
        score.setInt("score", highscores.get(i).score);   // Save Score

        scores.setJSONObject(i, score);
      }

      // Save to file
      saveJSONArray(scores, savedataDir + "highscores.json");
      println("Highscores saved!");
    }
    catch (Exception e) {
      println("Something went wrong! Failed to save highscores");
    }
  }

  //****************************************************************************
  //  Summary: Load level data from data/levels/levels.json and save
  //           to levels list.
  //****************************************************************************
  public void loadLevelData() {
    try {
      println("Loading levels...");

      // Load levels Json File
      JSONArray levelsJSON = loadJSONArray(levelDir + "levels.json");

      // Create Levels list
      levels = new ArrayList<Level>();

      // For each JSON object in file add to levels list
      for (int i = 0; i < levelsJSON.size(); i++) {
        // Cache current levels JSONObject
        JSONObject level = levelsJSON.getJSONObject(i);

        // Cache level modifiers
        int baseReward = level.getInt("baseReward");
        float rewardMultiplier = level.getFloat("rewardMultiplier");
        int ammoCount = level.getInt("ammo");
        boolean continuousWaves = level.getBoolean("continuousWaves");

        // Cache level RGB values
        int[] primaryRGB = level.getIntList("primaryRGB").toArray();
        int[] secondaryRGB = level.getIntList("secondaryRGB").toArray();
        int[] hudRGB = level.getIntList("hudRGB").toArray();
        int[] backgroundRGB = level.getIntList("backgroundRGB").toArray();

        // Create a list of the waves for this level
        List<Wave> waves = new ArrayList<Wave>();
        // Cache two-dimensional JSON array that we will be reading wave data from
        JSONArray wavesJSON = level.getJSONArray("waves");

        // Read through two dimensional array
        for (int x = 0; x < wavesJSON.size(); x++) {
          // Cache inner one dimensional array at x
          JSONArray wave = wavesJSON.getJSONArray(x);
          // Add new wave to waves list
          waves.add(new Wave(wave.getString(0), wave.getInt(1), wave.getFloat(2)));
        }

        // Add finalised level to levels list
        levels.add(new Level(waves, continuousWaves, baseReward, rewardMultiplier,
          ammoCount, primaryRGB, secondaryRGB, hudRGB, backgroundRGB));
      }

      // Fill out remaining highscore slots with empty values
      while (highscores.size() < maxNumOfHighscores) {
        highscores.add(new Score());
      }

      println("Levels loaded!");
    }
    catch (Exception e) {
      println("Something went wrong! Failed to load level data");
    }
  }

  //****************************************************************************
  //  Summary: Setter for highscore array list, saves highscores to
  //           highscores.json when called.
  //  Params: scores: What to set the highscores list to.
  //****************************************************************************
  public void setHighscores(List<Score> scores) {
    // Ensure that new list size is not greater than maxNumOfHighscores
    // If it is trim it to size
    if (scores.size() > maxNumOfHighscores) {
      scores = scores.subList(0, maxNumOfHighscores);
    }

    // Set highscores list to new list
    highscores = scores;
    saveHighscores(); // Make sure to save highscores when list to modified
  }

  //****************************************************************************
  //  Summary: Getter for highscore array list
  //  Return: ArrayList<Score>
  //****************************************************************************
  public List<Score> getHighscores() {
    return highscores;
  }

  //****************************************************************************
  //  Summary: "Getter" for highscore array list.
  //           Creates a deep copy of the levels list in order to
  //           prevent modification of loaded levels.
  //  Return: ArrayList<Score>
  //****************************************************************************
  public List<Level> getLevels() {
    List<Level> copyOfLevels = new ArrayList<Level>();

    for (Level level : levels)
      copyOfLevels.add(level.clone());

    return copyOfLevels;
  }

  //****************************************************************************
  //  Summary: Load user preferences from data/userPreferences.json
  //****************************************************************************
  public void loadUserPreferences() {
    try {
      println("Loading user preferences...");
      JSONArray userPrefsJSON = loadJSONArray(dataDir + "userPreferences.json");
      JSONObject userPrefs = userPrefsJSON.getJSONObject(0);

      cheatsEnabled = userPrefs.getBoolean("cheatsEnabled");
      debugMode = userPrefs.getBoolean("debugEnabled");
      println("Loaded user preferences!");
    }
    catch (Exception e) {
      println(e);
    }
  }

  //****************************************************************************
  //  Summary: Save user preferences to data/userPreferences.json
  //****************************************************************************
  public void saveUserPreferences() {
    try {
      println("Saving user preferences...");
      // Create JSONArray
      JSONArray userPreferences = new JSONArray();

      // Create prefs object
      JSONObject prefs = new JSONObject();
      prefs.setBoolean("cheatsEnabled", cheatsEnabled);
      prefs.setBoolean("debugEnabled", debugMode);

      // Add prefs to JSONArray
      userPreferences.setJSONObject(0, prefs);

      // Save to file
      saveJSONArray(userPreferences, dataDir + "userPreferences.json");
      println("User preferences saved!");
    }
    catch (Exception e) {
      println(e);
    }
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Score object, used for storing score data
//******************************************************************************
public class Score {

  public String name; // user name
  public int score;   // user score

  //****************************************************************************
  //  Summary: Constructor, when called create an "empty" score
  //****************************************************************************
  public Score() {
    name = "...............";
    score = 0;
  }

  //****************************************************************************
  //  Summary: Constructor
  //  Params: name: Name of user
  //          score: Score of user
  //****************************************************************************
  public Score(String name, int score) {
    this.name = name;
    this.score = score;
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Enum for all spawnable missiles in game. Used in spawning missiles
//******************************************************************************
public enum MissileTypes {
    BASICMISSILE,
    FASTMISSILE,
    SMARTMISSILE,
    DUMBMISSILE,
    TESTMISSILE,
}

//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Base missile class, stores all data and methods related to
//         missile logic.
//******************************************************************************
public class Missile {

  private MissileSpawner spawner; // Missile spawner that this missile belongs to
  private IMissileBrain brain;    // Missile AI Brain

  // Missile coorinates
  protected Transform transform; // Missile position and size
  protected PVector launchPos;   // PVector for the missiles origin

  // Missile properties
  protected float speed;             // Missie speed
  protected int colour;              // Missile colour
  protected float explosionDiameter; // Size of the explosions diameter

  // Trail visuals
  private final float trailDelay = 0.1f; // Delay for spawning trail segments
  private float trailDelayCounter;       // Counter for spawning trail segments
  private Trail trail;                   // Missile trail
  private boolean destroyed;             // Is the missile destroyed?

  //****************************************************************************
  //  Summary: Constructor
  //  Params: spawner - The missile spawner that created this missile
  //          brain - The AI Brain for this missile
  //****************************************************************************
  public Missile(MissileSpawner spawner, IMissileBrain brain) {
    this.spawner = spawner;
    this.brain = brain;

    // Spawn missile and set launch position
    this.transform = new Transform(spawner.randomSpawnPosition(),
      new PVector(15, 15));
    this.launchPos = transform.position;

    // Set base missile properties
    this.speed = 0;
    this.colour = 0;
    this.explosionDiameter = 80;

    // Setup visuals
    this.trailDelayCounter = 0;
    this.trail = gameController.NewTrail();
    this.destroyed = false;

    // initialize missile brain
    brain.initialize(this);
  }

  //****************************************************************************
  //  Summary: Called every frame while game is controller is
  //           running. Every frame we calculate the position of
  //           the missile and the path it's taking. We also must
  //           check if the missile has collided with a base.
  //****************************************************************************
  public void run() {

    // Destroy the missile of true
    if (destroyed)
     forceDestroy();
    
    // Run AI Brain to calculate positions
    brain.calculate();
    
    // Missile has hit the ground, self-destruct
    if (transform.position.y >= height - 40) {
      // Check for collision against living bases
      for (Base base : environment.getAliveBases()) {
        // If 
        if (Collision.circleSquareCollision(this.transform.position,
              this.explosionDiameter / 2, base.baseTransform)) {
          environment.destroyBase(base.getID());
          content.playSound("BaseCollapse");
        }
      }

      destroy();
    }

    // Check if this missile has collided with a living base.
    // If the missile is above the bases in the sky there is no need to
    // check if the missile has hit a base
    if (transform.position.y >= height - 60) {
      // Get alive bases
      List<Base> aliveBases = environment.getAliveBases();
      // Search for a collision against any living base
      for (Base base : aliveBases) {
        // Perform box collision
        if (transform.hasCollisionOccured(base.baseTransform)) {
          // Destroy base and missile
          environment.destroyBase(base.getID());
          content.playSound("BaseCollapse");
          destroy();
        }
      }
    }

    // Trail logic
    trailDelayCounter += time.getDeltaTimeSeconds();

    // Every trailDelay seconds add a new segment to the trail
    if (trailDelayCounter > trailDelay) {
      trailDelayCounter = 0;
      PVector ps = new PVector(transform.position.x + transform.width / 2,
        transform.position.y + transform.height / 2);
      trail.addSegment(ps);
    }
  }

  //****************************************************************************
  //  Summary: Called every frame while game is running.
  //           When called draw the physical missile to the screen
  //****************************************************************************
  public void draw() {
    // Set Colour
    fill(colour);

    // Draw the missile
    rect(transform.position.x, transform.position.y,
      transform.width, transform.height);
  }

  //****************************************************************************
  //  Summary: Causes missile to explode and destroys missile object
  //****************************************************************************
  private void destroy() {
    // Play explosion sound
    content.playSound("flakExplosion");

    // Create a new missile explosion
    // Get explosion position
    PVector pos = this.transform.getCenter();
    // Add explosion to list
    gameController.addMissileExplosion(new Explosion(pos, explosionDiameter, false));

    // Start despawning trail
    trail.destroyed = true; //should probably start to use destructors.

    // Destroy missile in spawner
    spawner.destroyMissile(this);
  }
  
  //****************************************************************************
  //  Summary: Destroy the missile without exploding
  //****************************************************************************
  private void forceDestroy() {
    // Start despawning trail
    trail.destroyed = true; //should probably start to use destructors.
    
    // Destroy missile in spawner
    spawner.destroyMissile(this);
  }

  //****************************************************************************
  //  Summary: Setter for destroyed
  //****************************************************************************
  public void setDestroyed(boolean destroyed) {
    this.destroyed = destroyed;
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: MissileBrain Interface, used when implementing new
//         missile logic.
//******************************************************************************
public interface IMissileBrain {
  public void initialize(Missile missile);
  public void calculate();
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Missile AI used for testing. This missile simply falls towards
//         the ground with no target.
//******************************************************************************
public class DumbBrain implements IMissileBrain {

  private Missile missile; // Reference to missile

  private final int minSpeed = 40; // Minimum speed of missile
  private final int maxSpeed = 70; // Maximum speed of missile

  //****************************************************************************
  //  Summary: Constructor
  //  Params: missile - Reference to missile
  //****************************************************************************
  public void initialize(Missile missile) {
    // Cache missile
    this.missile = missile;

    // Missile properties
    missile.speed = random(minSpeed, maxSpeed);
    missile.colour = 200;
  }

  //****************************************************************************
  //  Summary: Calculates the missiles path and position
  //****************************************************************************
  public void calculate() {
    // Missile falls to ground
    missile.transform.position.y += missile.speed * time.getDeltaTimeSeconds();
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Most common missile type in game. This missile will target
//         a building and fly in a straight line towards it.
//
//  Implements: IMissileBrain
//******************************************************************************
public class BasicBrain implements IMissileBrain {

  private Missile missile; // Reference to missile

  private Base targetBase;        // Base that missile is targetting
  private PVector targetPosition; // Position that missile is targetting
  private PVector path;           // PVector for the path between origin and base

  private final int minSpeed = 40; // Minimum speed of missile
  private final int maxSpeed = 70; // Maximum speed of missile

  //****************************************************************************
  //  Summary: Sets up missile logic
  //  Params: missile - The parent missile
  //****************************************************************************
  public void initialize(Missile missile) {
    // Create reference to missile
    this.missile = missile;

    // Missile properties
    missile.speed = random(minSpeed, maxSpeed);
    missile.colour = 200;

    // Get Missile target
    targetBase = findTargetBase();
    targetPosition = new PVector(targetBase.getXLocation() + 20, height - 45);
    path = new PVector(targetPosition.x - missile.launchPos.x,
      targetPosition.y - missile.launchPos.y);
  }

  //****************************************************************************
  //  Summary: Calculates the missiles path and position
  //****************************************************************************
  public void calculate() {
    path.normalize();
    path.mult(missile.speed);
    missile.transform.position.x += path.x * time.getDeltaTimeSeconds();
    missile.transform.position.y += path.y * time.getDeltaTimeSeconds();
  }

  //****************************************************************************
  //  Summary: Used to find a suitable base to target
  //  Return: Base - base to target
  //****************************************************************************
  private Base findTargetBase() {
    // Get list of living bases
    List<Base> aliveBases = environment.getAliveBases();
    // Choose a random target from the list
    Base target = aliveBases.get((int)random(0, aliveBases.size()));

    // Return random alive base
    return target;
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Faster version of the basic missile type.
//
//  Extends: Basic brain
//******************************************************************************
public class FastBrain extends BasicBrain {
  
  private final int minSpeed = 80;  // Minimum speed of missile
  private final int maxSpeed = 120; // Maximum speed of missile
  
  //****************************************************************************
  //  Summary: Sets up missile logic
  //  Params: missile - The parent missile
  //****************************************************************************
  public void initialize(Missile missile) {
    super.initialize(missile);
    missile.speed = random(minSpeed, maxSpeed);
  }
  
  //****************************************************************************
  //  Summary: Calculates the missiles path and position
  //****************************************************************************
  public void calculate() {
    super.calculate();
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Most common missile type in game. This missile will target
//         a building and fly in a straight line towards it.
//
//  Implements: IMissileBrain
//******************************************************************************
public class SmartBrain implements IMissileBrain {

  private Missile missile; // Reference to missile

  private Base targetBase;        // Base that missile is targetting
  private PVector targetPosition; // Position that missile is targetting
  private PVector path;           // PVector for the path between origin and base

  private final int minSpeed = 40; // Minimum speed of missile
  private final int maxSpeed = 70; // Maximum speed of missile

  //****************************************************************************
  //  Summary: Sets up missile logic
  //  Params: missile - The parent missile
  //****************************************************************************
  public void initialize(Missile missile) {
    // Cache missile
    this.missile = missile;

    // Missile properties
    missile.speed = random(minSpeed, maxSpeed);
    missile.colour = 200;

    // Get Missile target
    targetBase = findTargetBase();
    targetPosition = new PVector(targetBase.getXLocation() + 20, height - 45);
    path = calcPath();
  }

  //****************************************************************************
  //  Summary: Calculates the missiles path and position
  //****************************************************************************
  public void calculate() {

    // If the targetting base is destroyed and there are still alive bases,
    // find the next closest base to target
    if (targetBase.isDestroyed() && environment.getAliveBases().size() > 0) {
      targetBase = findTargetBase();
      targetPosition = new PVector(targetBase.getXLocation() + 20, height - 45);
      path = calcPath();
    }

    path.normalize();
    path.mult(missile.speed);
    missile.transform.position.x += path.x * time.getDeltaTimeSeconds();
    missile.transform.position.y += path.y * time.getDeltaTimeSeconds();
  }

  //****************************************************************************
  //  Summary: Calculates the missiles path
  //  Return: PVector path
  //****************************************************************************
  private PVector calcPath() {
    return path = new PVector(targetPosition.x - missile.launchPos.x,
      targetPosition.y - missile.launchPos.y);
  }

  //****************************************************************************
  //  Summary: Find the closest alive base to the target
  //  Return: Base - base to target
  //****************************************************************************
  private Base findTargetBase() {
    // Get list of living bases
    List<Base> aliveBases = environment.getAliveBases();

    // Find the closest base from the list
    Base closestBase = aliveBases.get(0);
    float distance = PVector.dist(missile.transform.getCenter(), closestBase.getPosition());

    // Loop though alive bases
    for (Base base : aliveBases) {
      float newDistance = PVector.dist(base.getPosition(), missile.transform.getCenter());
      if (newDistance < distance) {
        closestBase = base;
        distance = newDistance;
      }
    }

    // Return random alive base
    return closestBase;
  }
}


//****************************************************************
//  Authors: Scott Crooks
//
//  Usage: Missile AI used for testing. This missile does nothing.
//
//  Implements: IMissileBrain
//****************************************************************
public class TestBrain implements IMissileBrain {

  //****************************************************************************
  //  Summary: Sets up missile logic
  //  Params: missile - The parent missile
  //****************************************************************************
  public void initialize(Missile missile) {
    // Does nothing
  }

  //****************************************************************************
  //  Summary: Calculates the missiles path and position
  //****************************************************************************
  public void calculate() {
    // Does nothing
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Handles missile spawning and spawn position
//******************************************************************************
public class MissileSpawner {
  
  private final GameController controller; 
  private PVector spawnZone = new PVector(width, -10);
  
  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public MissileSpawner(GameController controller) {
    this.controller = controller; 
  }
  
  //****************************************************************************
  //  Summary: Get a random spawn position based on spawnZone PVector
  //  Return: PVector, random location in spawnZone
  //****************************************************************************
  public PVector randomSpawnPosition() {
      return new PVector(random(0, spawnZone.x), 
                         random(0, spawnZone.y));
  }
  
  //****************************************************************************
  //  Summary: Get a random spawn position based on spawnZone PVector and
  //           specified transform. 
  //  Params: transform - Transform to base spawn position on
  //  Return: PVector, random location in spawnZone
  //****************************************************************************
  public PVector randomSpawnPosition(Transform transform) {
      return new PVector(random(0, spawnZone.x - transform.width), 
                         random(0, spawnZone.y - transform.height));
  }
  
  //****************************************************************************
  //  Summary: Spawn a missile based on entered missileType
  //  Params: missileType - MissileTypes enum for specifying missile type
  //****************************************************************************
  public void spawnMissile(MissileTypes missileType) {
    switch (missileType) {
      case DUMBMISSILE:  // Spawn dummy missile
                         controller.enemyMissiles.add(new Missile(this, new DumbBrain()));
                         break;
      case BASICMISSILE: // Spawn basic missile
                         controller.enemyMissiles.add(new Missile(this, new BasicBrain()));
                         break;
      case FASTMISSILE: // Spawn fast missile
                         controller.enemyMissiles.add(new Missile(this, new FastBrain()));
                         break;
      case SMARTMISSILE: // Spawn smart missile
                         controller.enemyMissiles.add(new Missile(this, new SmartBrain()));
                         break;
      case TESTMISSILE:  // Spawn test missile
                         controller.enemyMissiles.add(new Missile(this, new TestBrain()));
                         break;
      default: println("MissileSpawner: ERROR: Missile type does not exist or is not implemented!");
    }
  }
  
  //****************************************************************************
  //  Summary: Removes a missile from the game
  //  Params: missile - missile reference to destroy
  //****************************************************************************
  public void destroyMissile(Missile missile) {
    // This is an expensive operation, however, as long as we aren't
    // removing hundreds of missile at a time the performance impact should be negligible.
    gameController.enemyMissiles.remove(missile);
  }
}

//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Static class for missile utils
//******************************************************************************
public static class MissileUtils {
  
  //****************************************************************************
  //  Summary: Converts a string to a MissileTypes enum
  //  Params: missileType - missileType string to convert to enum
  //****************************************************************************
  public static MissileTypes getMissileTypeFromString(String missileType) {
    switch(missileType) {
      case "DUMBMISSILE":  return MissileTypes.DUMBMISSILE;
      case "BASICMISSILE": return MissileTypes.BASICMISSILE;
      case "FASTMISSILE":  return MissileTypes.FASTMISSILE;
      case "SMARTMISSILE": return MissileTypes.SMARTMISSILE;
      case "TESTMISSILE":  return MissileTypes.TESTMISSILE;
      default: // If missile type isn't found return basic missile
               println("Missile type \"" + missileType + "\" not recognised! Defaulting to Basic missile");
               return MissileTypes.BASICMISSILE;
    }
  }
}
//******************************************************************************
//  Authors: Andrew McKenzie, Scott Crooks
//
//  Usage: Draws the ground, defense system and creates instances of the Base class
//
//  Changes:
//    8 May -- Robert -- Moved defenceMissiles to GameController.pde
//******************************************************************************
public class Environment {

  private final float xCenter;      // Center width of screen
  private final float spacing;      // Spacing between each base
  private final float[] xLocBases;  // list of x positions to draw each Base
  private Base[] bases;             // Array of all bases
  private boolean allBasesDestroyed;// Are all of the bases destroyed?
  private int[] primaryRGB;         // Primary RGB values for game
  private int[] secondaryRGB;       // Secondary RGB values for game
  private int[] hudRGB;             // HUD RGB values for overlay

  //****************************************************************************
  //  Summary: Constructor setting the center point on x-axis and initilizing the bases
  //****************************************************************************
  public Environment() {
    xCenter = width/2;

    // Initialize RGB arrays
    primaryRGB = new int[3];
    secondaryRGB = new int[3];
    hudRGB = new int[3];
    
    // calculating the spacing for bases in relation to screen width
    spacing = (((width/2)-190)/4);

    // Array of base x locations. Bases will be drawn at these positions
    xLocBases = new float[] {(-spacing*3)-170, (-spacing*2)-130, -spacing-90,
      spacing+50, (spacing*2)+90, (spacing*3)+130};

    // Initializing the array of Bases to be defended
    bases = new Base[6];

    // Initilizing the bases to be defended
    for (int i = 0; i < bases.length; i++)
      bases[i] = new Base(xLocBases[i], false, i);

    // Reset environment
    resetEnvironment();
  }

  //****************************************************************************
  //  Summary: Resets environment on new game
  //****************************************************************************
  public void resetEnvironment() {
    allBasesDestroyed = false;

    for (int i = 0; i < bases.length; i++)
      bases[i].setDestroyed(false);
      
    setPrimaryRGB(237, 209, 139);  
    setSecondaryRGB(165, 133, 145);
    setHUDRGB(255, 255, 255);
  }

  //****************************************************************************
  //  Summary: Called every frame while game is running.
  //         This method draws the environment
  //****************************************************************************
  public void draw() {
    noStroke();
    int[] brgb = gameController.currentLevel.backgroundRGB;
    background(brgb[0], brgb[1], brgb[2]);

    drawEnvironment();   // Draws the Environment
    drawDefenseSystem(); // Draws the defense cannon tower
    cannon.drawCannon(); // Draws the defense cannon
    drawBases();         // Draws all the bases to the screen
    drawAmmo();          // Draws the remaining available ammo
  }

  //****************************************************************************
  //  Summary: Draws the environment backdrop. E.g. The ground and cliffs
  //****************************************************************************
  private void drawEnvironment() {
    // Draws base rectangle and sides
    fill(primaryRGB[0], primaryRGB[1], primaryRGB[2]);
    rect(0, height-30, width, height);
    rect(0, height-55, 20, 25);
    rect(width-20, height-55, 20, 25);
  }

  //****************************************************************************
  //  Summary: Draws the tower that the defense cannon sits on
  //****************************************************************************
  private void drawDefenseSystem() {
    fill(primaryRGB[0], primaryRGB[1], primaryRGB[2]);
    rect(xCenter-50, height-35, 100, 10);
    rect(xCenter-45, height-40, 90, 10);
    rect(xCenter-40, height-45, 80, 10);
    ellipseMode(CENTER);
    arc(xCenter, height-45, 50, 25, PI, TWO_PI);
  }

  //****************************************************************************
  //  Summary: Draws the available ammo as rectangles on the screen
  //****************************************************************************
  private void drawAmmo() {
    // Draws rectangle represent how much ammo is left
    for (int i = 0, space = 0; i<cannon.getAmmo(); i++, space += 8) {
      int start = (4*cannon.getAmmo());
      fill(secondaryRGB[0], secondaryRGB[1], secondaryRGB[2]);
      rect(width/2-start+space, height-20, 5, 10);
    }
  }

  //****************************************************************************
  //  Summary: Draws all the bases to the screen. If a base is destroyed a 
  //           ruined variation will be drawn instead.
  //****************************************************************************
  private void drawBases() {
    // Iterate over the array of bases
    for (int i = 0; i < bases.length; i++) {
      // If the base is not destroyed draw it
      if (!bases[i].destroyed)
        bases[i].drawBuilding(bases[i].getXLocation());

      // If the base is destroyed draw a ruined version
      else
        bases[i].drawCollapsedBase(bases[i].getXLocation());
    }
  }

  //****************************************************************************
  //  Summary: Returns a list of the bases that have not been destroyed
  //  Return: List<Base>
  //****************************************************************************
  public List<Base> getAliveBases() {
    List<Base> aliveBases = new ArrayList<Base>();

    for (Base base : bases) {
      if (!base.isDestroyed())
        aliveBases.add(base);
    }

    return aliveBases;
  }

  //****************************************************************************
  //  Summary: Call to destroy a specific base
  //  Params: Index - Index of base in bases array
  //****************************************************************************
  public void destroyBase(int index) {
    bases[index].setDestroyed(true);

    if (getAliveBases().size() == 0)
      this.allBasesDestroyed = true;
  }

  //****************************************************************************
  //  Summary: Getter for allBasesDestroyed
  //  Return: boolean
  //****************************************************************************
  public boolean isAllBasesDestroyed() {
    return this.allBasesDestroyed;
  }
  
  //****************************************************************************
  //  Summary: setter for primaryRGB
  //  Params: r - Red channel value
  //          g - Green channel value
  //          b - Blue channel value
  //****************************************************************************
  public void setPrimaryRGB(int r, int g, int b) {
    this.primaryRGB[0] = r;
    this.primaryRGB[1] = g;
    this.primaryRGB[2] = b;
  }
  
  //****************************************************************************
  //  Summary: setter for primaryRGB
  //  Params: rgb - Array of size 3 representing RGB values
  //****************************************************************************
  public void setPrimaryRGB(int[] rgb) {
    this.primaryRGB[0] = rgb[0];
    this.primaryRGB[1] = rgb[1];
    this.primaryRGB[2] = rgb[2];
  }
  
  //****************************************************************************
  //  Summary: setter for secondaryRGB
  //  Params: r - Red channel value
  //          g - Green channel value
  //          b - Blue channel value
  //****************************************************************************
  public void setSecondaryRGB(int r, int g, int b) {
    this.secondaryRGB[0] = r;
    this.secondaryRGB[1] = g;
    this.secondaryRGB[2] = b;
    
    // Update bases with new secondary colour
    updateBaseColours();
  }
  
  //****************************************************************************
  //  Summary: setter for secondaryRGB
  //  Params: rgb - Array of size 3 representing RGB values
  //****************************************************************************
  public void setSecondaryRGB(int[] rgb) {
    this.secondaryRGB[0] = rgb[0];
    this.secondaryRGB[1] = rgb[1];
    this.secondaryRGB[2] = rgb[2];
    
    // Update bases with new secondary colour
    updateBaseColours();
  }
  
  //****************************************************************************
  //  Summary: Getter for secondaryRGB
  //  Return: Returns an int array of rgb colour channels
  //****************************************************************************
  public int[] getSecondaryRGB() {
    return this.secondaryRGB;
  }
  
  //****************************************************************************
  //  Summary: setter for hudRGB
  //  Params: r - Red channel value
  //          g - Green channel value
  //          b - Blue channel value
  //****************************************************************************
  public void setHUDRGB(int r, int g, int b) {
    this.hudRGB[0] = r;
    this.hudRGB[1] = g;
    this.hudRGB[2] = b;
  }
  
  //****************************************************************************
  //  Summary: setter for hudRGB
  //  Params: rgb - Array of size 3 representing RGB values
  //****************************************************************************
  public void setHUDRGB(int[] rgb) {
    this.hudRGB[0] = rgb[0];
    this.hudRGB[1] = rgb[1];
    this.hudRGB[2] = rgb[2];
  }
  
  //****************************************************************************
  //  Summary: Getter for hudRGB
  //  Return: Returns an int array of rgb colour channels
  //****************************************************************************
  public int[] getHUDRGB() {
    return this.hudRGB;
  }
  
  //****************************************************************************
  //  Summary: Updates all bases with new secondary rgb colours
  //****************************************************************************
  private void updateBaseColours() {
    for (Base base : bases) {
      base.setBaseColour(secondaryRGB[0], secondaryRGB[1], secondaryRGB[2]);
    }
  }
}


//******************************************************************************
//  Authors: Andrew McKenzie
//
//  Usage: A class for creating a base object and drawing the screen
//******************************************************************************
public class Base {

  private final float xLocation;   // x location of base
  private float xCenter;           // x center of base
  private boolean destroyed;       // Is the base destroyed?
  private Transform baseTransform; // Base transform
  private final int id;            // ID of base.
  private int[] baseRGB;        // Colour of the base

  //****************************************************************************
  //  Summary: Constructor, takes a float as an argument and adds it to the centerX value
  //         also sets the isVisible boolean and xCenter variable to the center of the screens x-axis
  //  Params: xLocation - x location of base on screen
  //          destroyed - Is the base destroyed
  //****************************************************************************
  public Base(float xLocation, boolean destroyed, int id) {
    this.xCenter = width/2;
    this.xLocation = xCenter+xLocation;
    this.destroyed = destroyed;
    this.id = id;
    this.baseTransform = new Transform(new PVector(xCenter+xLocation, height-65), 40, 50);
    this.baseRGB = new int[3];
  }

  //****************************************************************************
  //  Summary: Takes a float as an input and draws a base in that location.
  //  Params: xLoc - x location of base on screen.
  //****************************************************************************
  public void drawBuilding(float xLocation) {
    noStroke();
    fill(baseRGB[0], baseRGB[1], baseRGB[2]);
    rect(xLocation, height-35, 4, 20);
    rect(xLocation+4, height-45, 4, 30);
    rect(xLocation+8, height-65, 4, 50);
    rect(xLocation+12, height-35, 4, 20);
    rect(xLocation+16, height-45, 4, 30);
    rect(xLocation+20, height-55, 4, 40);
    rect(xLocation+24, height-65, 4, 50);
    rect(xLocation+28, height-50, 4, 35);
    rect(xLocation+32, height-45, 4, 30);
    rect(xLocation+36, height-35, 4, 20);
  }

  //****************************************************************************
  //  Summary: Draws the collapsed base
  //****************************************************************************
  public void drawCollapsedBase(float xLoc) {
    noStroke();
    fill(baseRGB[0], baseRGB[1], baseRGB[2]);
    rect(xLoc, height-33, 4, 3);
    rect(xLoc+4, height-34, 4, 4);
    rect(xLoc+8, height-36, 4, 6);
    rect(xLoc+12, height-33, 4, 3);
    rect(xLoc+16, height-34, 4, 4);
    rect(xLoc+20, height-35, 4, 5);
    rect(xLoc+24, height-36, 4, 6);
    rect(xLoc+28, height-34, 4, 4);
    rect(xLoc+32, height-34, 4, 4);
    rect(xLoc+36, height-33, 4, 3);
  }

  //****************************************************************************
  //  Summary: Getter for xLocation of base.
  //  Return: float - x coordinate of base
  //****************************************************************************
  public float getXLocation() {
    return this.xLocation;
  }
  
  //****************************************************************************
  //  Summary: Getter for Pvector of base.
  //  Return: PVector - position of base
  //****************************************************************************
  public PVector getPosition() {
    return this.baseTransform.position;
  }

  //****************************************************************************
  //  Summary: Getter to return the whether the Base object is visible
  //  Return: boolean - is the base destroyed?
  //****************************************************************************
  public boolean isDestroyed() {
    return this.destroyed;
  }

  //****************************************************************************
  //  Summary: Setter to set whether the Base object is visible
  //****************************************************************************
  public void setDestroyed(boolean visible) {
    this.destroyed = visible;
  }

  //****************************************************************************
  //  Summary: Getter for base id
  //  Return: int - base id
  //****************************************************************************
  public int getID() {
    return this.id;
  }
  
  //****************************************************************************
  //  Summary: Setter for baseRGB
  //  Params: r - Red channel value
  //          g - Green channel value
  //          b - Blue channel value
  //****************************************************************************
  public void setBaseColour(int r, int g, int b) {
    this.baseRGB[0] = r;
    this.baseRGB[1] = g;
    this.baseRGB[2] = b;
  }
}
//******************************************************************************
//  Authors: Scott Crooks, Robert Preston
//
//  Usage: Handles game data. E.g. Score, current level, missiles
//******************************************************************************
public class GameController {

  public final MissileSpawner missileSpawner; // Controls spawning missiles

  public int score;          // Tracks current score
  public int levelIndex;     // Tracks current level
  public Level currentLevel; // Current level
  public List<Level> levels; // List of all levels in game

  public List<Missile> enemyMissiles;              // Spawned enemy missiles
  public List<DefenceMissile> defenceMissiles;     // Spawned defence missiles
  public List<Explosion> missileExplosions; // Spawned explosions
  public List<Trail> trails;                       // Spawned trails

  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public GameController() {
    missileSpawner = new MissileSpawner(this);

    // Setup lists
    levels = new ArrayList<Level>();
    enemyMissiles = new ArrayList<Missile>();
    defenceMissiles = new ArrayList<DefenceMissile>();
    missileExplosions = new ArrayList<Explosion>();
    trails = new ArrayList<Trail>();

    // Prepare game with Reset
    reset();
  }

  //****************************************************************************
  //  Summary: Resets game controller and prepares for new game
  //****************************************************************************
  public void reset() {
    // Reset environment
    environment.resetEnvironment();

    // Reset data
    score = 0;
    levelIndex = 0;

    // Copy levels from content
    levels.clear();
    levels = content.getLevels();
    for (Level level : levels)
      println(level.levelOngoing);

    // Clean up lists
    enemyMissiles.clear();
    defenceMissiles.clear();
    missileExplosions.clear();
    trails.clear();

    // Allocate curent level;
    currentLevel = levels.get(levelIndex);

    // Reset bases
    for (int i = 0; i < environment.bases.length; i++)
      environment.bases[i].setDestroyed(false);

    // Add ammo to defence cannon
    cannon.setAmmo(currentLevel.ammoCount);
    cannon.setRGB(currentLevel.secondaryRGB);
    reticle.setRGB(currentLevel.getHUDRGB());
  }

  //****************************************************************************
  //  Summary: Called every frame while a game is ongoing
  //****************************************************************************
  public void run() {
    if (!currentLevel.levelOngoing)
      nextlevel();

    if (environment.isAllBasesDestroyed())
      gameOver();

    // Run logic for current level
    currentLevel.run();

    // Run/Draw missiles
    handleMissiles();
  }

  //****************************************************************************
  //  Summary: Handles drawing missiles and calculating missile positions
  //****************************************************************************
  public void handleMissiles() {
    // Run/Draw the trails
    // We do this first as to not overlap the missiles
    if (trails.size() > 0) {
      for (int i = 0; i < trails.size(); i++) {
        Trail trail = trails.get(i);
        trail.draw();
      }
    }

    // Draw missiles
    for (int i = 0; i < enemyMissiles.size(); i++) {
      enemyMissiles.get(i).draw();
      enemyMissiles.get(i).run();
    }

    // Run/Draw defenceMissiles
    for (int i = 0; i < defenceMissiles.size(); i++) {
      DefenceMissile missile = defenceMissiles.get(i);
      missile.draw();
      missile.run();
      if (missile.onTarget()) {
        missileExplosions.add(new Explosion(missile.transform.position, 120, true));
        content.playSound("flakExplosion");
        missile.destroy();
        defenceMissiles.remove(i);
      }
    }

    // Run/Draw missileExplosions
    for (int i = 0; i < missileExplosions.size(); i++) {
      Explosion explosion = missileExplosions.get(i);
      explosion.draw();

      // If explosion is friendly check collision with enemy missiles
      if (explosion.friendly && !explosion.exploded) {
        for (int x = 0; x < enemyMissiles.size(); x++) {
          Missile missile = enemyMissiles.get(x);
          
          // Check collision
          if (Collision.circleSquareCollision(explosion.center, explosion.radius, missile.transform)) {
            explosion.exploded = true;
            missile.setDestroyed(true);
            
            // Increase score for missile destroyed
            score += currentLevel.baseReward * currentLevel.rewardMultiplier;
          }
        }
      }

      if (explosion.lifespan < 1)
        missileExplosions.remove(explosion);
    }
  }

  //****************************************************************************
  //  Summary: Creates a new trail piece
  //****************************************************************************
  public Trail NewTrail() {
    Trail trail = new Trail();
    trails.add(trail);
    return trail;
  }

  //****************************************************************************
  //  Summary: Attempts to start the next level, if there are no levels left it
  //           ends game. If there are levels left, prepare for next level.
  //****************************************************************************
  public void nextlevel() {
    
    // If there are still missiles in scene wait for them to despawn
    // before starting the next wave.
    if (gameController.enemyMissiles.size() > 0)
      return;
    
    // Increase index to represent next level
    levelIndex++;

    // Add bonus score for remaining ammo and bases
    score += cannon.getAmmo() * (currentLevel.baseReward / 2);
    score += environment.getAliveBases().size() * (currentLevel.baseReward * currentLevel.rewardMultiplier);

    // If no more levels remain end game
    if (levelIndex >= levels.size()) {
      gameOver();
      return;
    }

    // Get the next level from levels list
    currentLevel = levels.get(levelIndex);
    cannon.setAmmo(currentLevel.ammoCount);

    // Reset bases
    for (int i = 0; i < environment.bases.length; i++) {
      environment.bases[i].setDestroyed(false);
    }

    environment.setPrimaryRGB(currentLevel.getPrimaryRGB());
    environment.setSecondaryRGB(currentLevel.getSecondaryRGB());
    environment.setHUDRGB(currentLevel.getHUDRGB());
    cannon.setRGB(currentLevel.getSecondaryRGB());
    reticle.setRGB(currentLevel.getHUDRGB());
  }
  
  //****************************************************************************
  //  Summary: Force starts the next level
  //****************************************************************************
  public void forceNextLevel() {
    // Increase index to represent next level
    levelIndex++;

    // If no more levels remain end game
    if (levelIndex >= levels.size()) {
      gameOver();
      return;
    }

    // Get the next level from levels list
    currentLevel = levels.get(levelIndex);
    cannon.setAmmo(currentLevel.ammoCount);

    // Reset bases
    for (int i = 0; i < environment.bases.length; i++) {
      environment.bases[i].setDestroyed(false);
    }

    environment.setPrimaryRGB(currentLevel.getPrimaryRGB());
    environment.setSecondaryRGB(currentLevel.getSecondaryRGB());
    environment.setHUDRGB(currentLevel.getHUDRGB());
    cannon.setRGB(currentLevel.getSecondaryRGB());
    reticle.setRGB(currentLevel.getHUDRGB());
  }
  
  //****************************************************************************
  //  Summary: Force starts the next wave
  //****************************************************************************
  public void forceNextWave() {
    currentLevel.waveCompleted();
  }

  //****************************************************************************
  //  Summary: Ends the game and performs game over tasks
  //****************************************************************************
  public void gameOver() {
    // Set the hud to white
    environment.setHUDRGB(255, 255, 255);

    // We switch to highscore state for checking highscores
    stateManager.switchState(stateManager.highscoreState);
  }
  
  //****************************************************************************
  //  Usage: Add a new missile explosion
  //  Params: explosion = MissileExplosion to add
  //****************************************************************************
  public void addMissileExplosion(Explosion explosion) {
    this.missileExplosions.add(explosion);
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Manages data and functions for levels in game.
//
//  Implements: Cloneable - Used for copying level on game start
//******************************************************************************
public class Level implements Cloneable {
  
  public final List<Wave> waves;       // List of waves in this level
  public final boolean continuousWaves;// Should waves be continuous?
  public final float rewardMultiplier; // Reward multiplier for level
  public final int baseReward;         // Base reward for this level
  public final int ammoCount;          // The amount of ammo granted for level
  private final int[] primaryRGB;      // Primary RGB values for game
  private final int[] secondaryRGB;    // Secondary RGB values for game
  private final int[] hudRGB;          // HUD RGB values for overlay
  private final int[] backgroundRGB;   // Background rgb values

  private int currentWaveIndex; // Index of the running wave
  private Wave currentWave;     // The current running wave
  private float waveTimer;      // Timer for tracking spawn delay
  private int missilesSpawned;  // Total count of missiles spawned in wave so far
  public boolean levelOngoing;  // Is the level ongoing?

  //****************************************************************************
  //  Usage: Constructor
  //  Params: waves - List of waves to spawn in this level
  //          rewardMultiplier - reward multiplier for this level
  //          baseReward - base reward value for this level
  //          ammoCount - The amount of ammo the player gets for this level
  //****************************************************************************
  public Level(List<Wave> waves, boolean continuousWaves, int baseReward, 
    float rewardMultiplier, int ammoCount, int[] primaryRGB, int[] secondaryRGB, 
    int[] hudRGB, int[] backgroundRGB) {
    this.waves = waves;
    this.continuousWaves = continuousWaves;
    this.rewardMultiplier = rewardMultiplier;
    this.baseReward = baseReward;
    this.ammoCount = ammoCount;
    this.primaryRGB = primaryRGB;
    this.secondaryRGB = secondaryRGB;
    this.hudRGB = hudRGB;
    this.backgroundRGB = backgroundRGB;

    currentWaveIndex = 0;
    waveTimer = 0;
    missilesSpawned = 0;
    currentWave = waves.get(currentWaveIndex);
    levelOngoing = true;
  }

  //****************************************************************************
  //  Usage: Called every frame, runs core functionality for this level
  //  Params: None
  //  Returns: Void
  //****************************************************************************
  public void run() {
    // Has the wave spawned all of its requested missiles?
    if (missilesSpawned > currentWave.missileCount) {
      // If waves are continuous, start the next wave without waiting for
      // missiles to despawn.
      if (!continuousWaves) {
        // If there are no missiles spawned in request next wave
        if (!(gameController.enemyMissiles.size() > 0))
          waveCompleted();
      } else {
        waveCompleted();
      }
      return;
    }

    // Increase wave timer by delta seconds
    waveTimer += time.getDeltaTimeSeconds();

    // If timer is larger then spawn delay spawn enemies
    if (waveTimer >= currentWave.spawnDelay) {
      missilesSpawned++;
      gameController.missileSpawner.spawnMissile(currentWave.missileType);
      waveTimer = 0;
    }
  }

  //****************************************************************************
  //  Summary: Called once a wave is completed. We reset wave related counters
  //         here. If we detect there are no waves left we call levelCompleted
  //****************************************************************************
  public void waveCompleted() {
    currentWaveIndex++;

    // If there are no more waves left end level
    if (currentWaveIndex >= waves.size()) {
      levelCompleted();
      return;
    }

    // Prepare next wave
    waveTimer = 0;
    missilesSpawned = 0;
    currentWave = waves.get(currentWaveIndex);
  }

  //****************************************************************************
  //  Usage: Called once this level is completed. Here we end level
  //  Params: None
  //  Returns: Void
  //****************************************************************************
  public void levelCompleted() {
    levelOngoing = false;
  }

  //****************************************************************************
  //  Summary: Getter for primaryRGB
  //  Params: None
  //  Return: Returns an int array of rgb colour channels
  //****************************************************************************
  public int[] getPrimaryRGB() {
    return primaryRGB;
  }

  //****************************************************************************
  //  Summary: Getter for secondaryRGB
  //  Params: None
  //  Return: Returns an int array of rgb colour channels
  //****************************************************************************
  public int[] getSecondaryRGB() {
    return secondaryRGB;
  }

  //****************************************************************************
  //  Summary: Getter for hudRGB
  //  Params: None
  //  Return: Returns an int array of rgb colour channels
  //****************************************************************************
  public int[] getHUDRGB() {
    return hudRGB;
  }

  //****************************************************************************
  //  Usage: Creates a clone of this level
  //  Returns: Level
  //****************************************************************************
  @Override
    public Level clone() {
    Level level = new Level(this.waves, this.continuousWaves, this.baseReward, this.rewardMultiplier,
      this.ammoCount, this.primaryRGB, this.secondaryRGB, this.hudRGB, this.backgroundRGB);
    return level;
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Stores data related to individual waves within levels
//******************************************************************************
public class Wave {
  
  public final MissileTypes missileType;  // Missile type to spawn in wave
  public final int missileCount;          // How many missiles to spawn
  public final float spawnDelay;          // Delay between spawning missiles

  //****************************************************************************
  //  Usage: Constructor
  //  Params: missileType - What type of missile to spawn
  //          missileCount - How many missiles to spawn
  //          spawnDelay - Delay between spawning missiles
  //****************************************************************************
  public Wave(MissileTypes missileType, int missileCount, float spawnDelay) {
    this.missileType = missileType;
    this.missileCount = missileCount;
    this.spawnDelay = spawnDelay;
  }

  //****************************************************************************
  //  Usage: Constructor
  //  Params: missileType - What type of missile to spawn
  //          missileCount - How many missiles to spawn
  //          spawnDelay - Delay between spawning missiles
  //****************************************************************************
  public Wave(String missileType, int missileCount, float spawnDelay) {
    // Convert string to enum with utils class
    this.missileType = MissileUtils.getMissileTypeFromString(missileType);
    this.missileCount = missileCount;
    this.spawnDelay = spawnDelay;
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Controls and display for player reticle
//******************************************************************************
public class Reticle {

  private Transform transform; // Reticle transform
  private float reticleSpeed;  // Reticle movement speed
  private PVector constraints; // Screen constraints
  private int[] rgb;           // Reticle colour in rgb
  
  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public Reticle() {
    PVector size = new PVector(40, 8);
    PVector position = new PVector(width /2 - size.x / 2, height /2 - size.y - 2);
    this.transform = new Transform(position, size);
    this.reticleSpeed = 40;
    this.rgb = new int[3];
    this.rgb[0] = 255;
    this.rgb[1] = 255;
    this.rgb[2] = 255;
    
    // Set constraints and account for reticle size
    this.constraints = new PVector(width - size.x, height - size.y * 2); 
  }
  
  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public void draw() {
    noStroke();
    fill(rgb[0], rgb[1], rgb[2]);
    rect(transform.position.x, transform.position.y, transform.width, transform.height);
  }
  
  //****************************************************************************
  //  Summary: Reset reticle position to center of screen
  //****************************************************************************
  public void resetPosition() {
    transform.position = new PVector(width /2 - transform.width / 2, height /2 - transform.height - 2);
  }
  
  //****************************************************************************
  //  Summary: Move reticle up
  //****************************************************************************
  public void moveUp() {
    move(new PVector(0, -1));
  }
  
  //****************************************************************************
  //  Summary: Move reticle down
  //****************************************************************************
  public void moveDown() {
    move(new PVector(0, 1));
  }
  
  //****************************************************************************
  //  Summary: Move reticle left
  //****************************************************************************
  public void moveLeft() {
    move(new PVector(-1, 0));
  }
  
  //****************************************************************************
  //  Summary: Move reticle right
  //****************************************************************************
  public void moveRight() {
    move(new PVector(1, 0));
  }
  
  //****************************************************************************
  //  Summary: Move the reticle based upon the vector provided
  //  Params: movement - Movement vector for reticle. i.e. How far to move.
  //****************************************************************************
  public void move(PVector movement) {
    // Play reticle moving sound
    content.playSound("ReticleMove");
    
    // Checks to ensure reticle does not move outside of the screen/constraints set
    if (movement.x > 0) {
      if (transform.position.x + movement.x < constraints.x) 
        transform.position.x += movement.x * (reticleSpeed + time.getDeltaTimeSeconds());
    }
    
    if (movement.x < 0) {
      if (transform.position.x + movement.x > 0) 
        transform.position.x += movement.x * (reticleSpeed + time.getDeltaTimeSeconds());
    }
    
    if (movement.y > 0) {
      if (transform.position.y + movement.y < constraints.y) 
        transform.position.y += movement.y * (reticleSpeed + time.getDeltaTimeSeconds());
    }
    
    if (movement.y < 0) {
      if (transform.position.y + movement.y > 0) 
        transform.position.y += movement.y * (reticleSpeed + time.getDeltaTimeSeconds());
    }
  }
  
  //****************************************************************************
  //  Summary: Getter for reticle position
  //  Return: PVector reticle position
  //****************************************************************************
  public PVector getReticlePos(){
    return this.transform.position; 
  }
  
  //****************************************************************************
  //  Summary: Setter for reticle rgb
  //  Params: rgb - int array of rgb channels
  //****************************************************************************
  public void setRGB(int[] rgb) {
    this.rgb[0] = rgb[0];
    this.rgb[1] = rgb[1];
    this.rgb[2] = rgb[2];
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameState Interface, used when implementing new game states
//******************************************************************************
public interface GameState {
  public void run();         // Core loop, called every frame
  public void enter();       // Called when state is entered
  public void exit();        // Called when state is Exited
  public void drawDisplay(); // Called when attempting to draw state to screen.
  public void handleInput(); // Called when input is detected
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Statemanager, central state controller, controls game state,
//         switching states and other core functionality.
//
//  Important: If a new state is created add it to this controller.
//
//******************************************************************************
public class StateManager implements GameState {

  // Game States
  public final GameStateMainMenu mainMenuState;         // Main Menu state
  public final GameStateRunning runningState;           // Game Running state
  public final GameStatePaused pausedState;             // Game Paused state
  public final GameStateFinished gameOverState;         // Game Over state
  public final GameStateHighscore highscoreState;       // Highscore state
  public final GameStateAddHighscore addHighscoreState; // Add Highscore state

  // Current game state
  public GameState currentState;

  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public StateManager() {
    // Initialize States
    mainMenuState = new GameStateMainMenu();
    runningState = new GameStateRunning();
    pausedState = new GameStatePaused();
    gameOverState = new GameStateFinished();
    highscoreState = new GameStateHighscore();
    addHighscoreState = new GameStateAddHighscore();

    // Switch state to main menu
    switchState(mainMenuState);
  }

  //****************************************************************************
  //  Summary: Use to switch game state, will exit previous state and enter new state
  //  Params: nextState - State to switch to
  //****************************************************************************
  public void switchState(GameState nextState) {
    // Cache previous game state
    GameState prevState = currentState;

    // If state or prevState is null something has gone wrong and we will transition to the main menu state
    // This will also occur when the game is started for the first time as there will not be a previous state,
    // however, as we are attempting to display the main menu regardless this has been left as is.
    if (nextState == null || prevState == null) {
      if (!gameLaunching) // We only want to send this error when game is launching
        println("[StateManager] Looks like something went wrong! Returning to mainMenu");
      else
        println("[StateManager] Switching to Main Menu");
      currentState = mainMenuState;
      currentState.enter();
      return;
    }

    prevState.exit();          // Exit previous state
    currentState = nextState;  // Set new state
    currentState.enter();      // Enter new state
  }

  //****************************************************************************
  //  Summary: Core loop, called every frame
  //****************************************************************************
  public void run() {
    currentState.run();
  }

  //****************************************************************************
  //  Summary: Called when a state is entered
  //****************************************************************************
  public void enter() {
    currentState.enter();
  }

  //****************************************************************************
  //  Summary: Called when a state is Exited
  //****************************************************************************
  public void exit() {
    currentState.exit();
  }

  //****************************************************************************
  //  Summary: Called when attempting to draw hud to screen.
  //****************************************************************************
  public void drawDisplay() {
    // We intend to use the same colour for all hud elements
    // So we set it here
    fill(environment.getHUDRGB()[0], environment.getHUDRGB()[1], environment.getHUDRGB()[2]);
    // Draw current state dispplay
    currentState.drawDisplay();
  }

  //****************************************************************************
  //  Summary: Called when input is detected
  //****************************************************************************
  public void handleInput() {
    // If cheats are enabled use them
    if (cheatsEnabled)
      performCheats();

    // Toggle for debug mode
    if (key == '`') {
      debugMode = !debugMode;
      
      if (debugMode)
        println("Debug Mode Enabled");
      else
        println("Debug Mode Disabled");
    }
    
    // Toggle for cheats
    if (key == '~') {
      cheatsEnabled = !cheatsEnabled;
      
      if (cheatsEnabled)
        println("Cheats Enabled");
      else
        println("Cheats Disabled");
    }

    // Perform state specific input
    currentState.handleInput();
  }

  //****************************************************************************
  //  Summary: Handles global cheats
  //****************************************************************************
  private void performCheats() {
    switch(key) {
      case '[': // Slow down game
                time.decreaseSpeed(0.2f);
                return;
      case ']': // Speed up game
                time.increaseSpeed(0.2f);
                return;
      case '\\':// Reset Speed
                time.resetSpeedMultiplier();
                return;
     case '4':  //DEBUG: Increase score
                gameController.score += gameController.currentLevel.baseReward *
                  gameController.currentLevel.rewardMultiplier;
                return;
    }
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameStateRunning, core game loop, all methods while game is running
//         are executed here.
//
//  Implements: GameState
//******************************************************************************
public class GameStateRunning implements GameState {

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void enter() {
    // Set reticle position to center of screen
    reticle.resetPosition();
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void exit() {
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void run() {
    // Run game Controller
    gameController.run();

    // Draw reticle
    reticle.draw();
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void drawDisplay() {
    // Convert Score to String
    String scoreString = String.valueOf(gameController.score);

    // Display Score
    textSize(content.fontSizeTitle);
    text(scoreString, (width / 2) - scoreString.length() * 15, 20 + content.fontSizeTitle);
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void handleInput() {
    // "Reticle" movement controls
    switch(keyCode) {
      case UP:    reticle.moveUp();
                  break;
      case DOWN:  reticle.moveDown();
                  break;
      case LEFT:  reticle.moveLeft();
                  break;
      case RIGHT: reticle.moveRight();
                  break;
    }

    // Keybinds
    switch(key) {
      case '1': // Force end game
                gameController.gameOver();
                break;
      case '2': // Force end Level
                if (cheatsEnabled)
                  gameController.forceNextLevel();
                break;
      case '3': // Force end Wave
                if (cheatsEnabled)
                  gameController.forceNextWave();
                break;
      case 'p': // Pause Game logic
                stateManager.switchState(stateManager.pausedState);
                break;
      case ' ': // Firing cannon
                cannon.fireCannon();
    }
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameStatePaused, used to Pause the game
//
//  Implements: GameState
//******************************************************************************
public class GameStatePaused implements GameState {

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void run() {
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void enter() {
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void exit() {
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void drawDisplay() {
    // Convert Score to String
    String scoreString = String.valueOf(gameController.score);

    textSize(content.fontSizeTitle);

    // Display Score
    text(scoreString, (width / 2) - scoreString.length() * 15, 20 + content.fontSizeTitle);
    // Display Paused Text
    text("GAME PAUSED", (width / 2) - 165, (height / 2) - content.fontSizeTitle);
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void handleInput() {
    switch(key) {
      case '1': // Debug: Force game over
                stateManager.switchState(stateManager.highscoreState);
                break;
      case 'p': // Unpause game logic
                stateManager.currentState = stateManager.runningState;
                break;
    }
  }
}
//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameStateMainMenu, used to display MainMenu Graphics
//
//  Implements: GameState
//******************************************************************************
public class GameStateMainMenu implements GameState {
  
  private PVector uiPosition;     // Position of UI
  private BlinkingText startText; // "Press any key to start" blinker
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void run() {
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void enter() {
    // Setup ui positions
    uiPosition = new PVector(width /2 - 140, height /2 - 100);
    
    // Leaderboard
    highscoreLeaderboard.setPosition(new PVector(uiPosition.x - 10, uiPosition.y));
    
    // Blinking start game text
    startText = new BlinkingText(2, 1, "Press any key to start!", 
      content.fontSizeSubtitle, new PVector(uiPosition.x - 10, uiPosition.y + 300));
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void exit() {
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void drawDisplay() {
    
    // Display title
    textSize(content.fontSizeTitle);
    text("Missile Command", uiPosition.x - 70, uiPosition.y - 60);
    
    // Display leaderboard
    highscoreLeaderboard.display();
    
    // Draw blinking start game text
    startText.draw();
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void handleInput() {
    // When key is pressed start game
    stateManager.switchState(stateManager.runningState); 
  }
}

//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameStateHighscore, used to display display menu for new highscores
//
//  Implements: GameState
//******************************************************************************
public class GameStateHighscore implements GameState {
  
  private PVector uiPosition;
  private boolean saveHighscoreSelector; // Current selection that the selector is set to
  private SaveScore saveScore;           // Selector option chosen; e.g. YES - Add new highscore, NO - don't add

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void run() { 
    // Check if option has been selected
    switch (saveScore) {
      case YES:     stateManager.switchState(stateManager.addHighscoreState);
                    break;
      case NO:      stateManager.switchState(stateManager.gameOverState);
                    break;
    }
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void enter() {
    // If current score is not a highscore transition to game over state
    if (!highscoreLeaderboard.newHighscore(gameController.score))
      stateManager.switchState(stateManager.gameOverState);
    
    // Setup state
    uiPosition = new PVector(width / 2 - 135, height / 2 - 110);
    saveHighscoreSelector = true; // Set Selector to "YES"
    saveScore = SaveScore.UNKNOWN;// Set Selection to "UNKNOWN"
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void exit() {
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void drawDisplay() {
    // Draw "HIGHSCORE" title
    textSize(content.fontSizeTitle);
    text("HIGHSCORE!", uiPosition.x, uiPosition.y);

    // Draw subtitle
    textSize(content.fontSizeSubtitle);
    text("Do you want to add it to the list?", uiPosition.x - 90, uiPosition.y + 50);

    // Draw Yes/No Selection
    textSize(content.fontSizeSubtitle);
    text("\"Yes\" / \"No\"", uiPosition.x + 55, uiPosition.y + 80);

    // Draw the selector under selected option
    if (saveHighscoreSelector)
      rect(uiPosition.x + 66, uiPosition.y + 85, 43, 4);
    else
      rect(uiPosition.x + 160, uiPosition.y + 85, 28, 4);
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void handleInput() {
    // Control YES/NO selector
    switch(keyCode) {
      case LEFT:  saveHighscoreSelector = true; // Move selector to YES
                  break;
      case RIGHT: saveHighscoreSelector = false;// Move selector to NO
                  break;
    }

    // Select current option
    if (key == ' ') {
      if (saveHighscoreSelector) 
        saveScore = SaveScore.YES;
      else 
        saveScore = SaveScore.NO;
    }
  }
}

// Save score enum used in GameStateHighscore as a method of managing selection
enum SaveScore {
  UNKNOWN,
    YES,
    NO
}

//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameStateAddHighscore, manages data for adding a new highscore
//  Implements: GameState
//******************************************************************************
public class GameStateAddHighscore implements GameState {
  
  private String name;             // Entered name
  private int maxNameLength;       // Max length of name
  private String nameUnderline;    // Name underline
  private PVector uiPosition;      // Position of displays

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void run() {
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void enter() {
    // Reset state on enter
    name = "";
    maxNameLength = 8;
    nameUnderline = "________";
    uiPosition = new PVector(width / 2, height / 2);
  }

  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void exit() {
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void drawDisplay() {
    // Draw "HIGHSCORE" title
    textSize(content.fontSizeTitle);
    text("HIGHSCORE!", uiPosition.x - 120, uiPosition.y - content.fontSizeTitle - 100);

    // Draw enter name subtitle
    textSize(content.fontSizeSubtitle);
    text("Enter your name", uiPosition.x - 90, uiPosition.y - content.fontSizeSubtitle - 80);

    // Display name
    textSize(content.fontSizeSubtitle);
    text(name, uiPosition.x - 45, uiPosition.y - content.fontSizeSubtitle - 50);
    
    // Display name underline
    textSize(content.fontSizeSubtitle);
    text(nameUnderline, uiPosition.x - 45, uiPosition.y - content.fontSizeSubtitle - 40);
    
    // Draw instructions text
    textSize(content.fontSizeSubtitle);
    text("Press SPACE or RETURN to continue", uiPosition.x - 210, uiPosition.y - content.fontSizeSubtitle);
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void handleInput() {
    // Save score to current name
    if (keyCode == ENTER || key == ' ') {
      saveScore(); 
      return;
    }
    
    // Allow backspacing
    if (keyCode == BACKSPACE) {
      if (name != null && !name.trim().isEmpty()) {
        name = name.substring(0, name.length() - 1);
      }
      return;
    }

    // Return here so we don't record ASCII characters
    if (key == CODED) return; 

    // Return here so we don't go over max name length
    if (name.length() >= maxNameLength) return; 
    
    // Add key to current name and format
    name += key;               
    name.trim().toUpperCase();
  }
  
  //****************************************************************************
  //  Summary: Used to save score or exit state
  //****************************************************************************
  private void saveScore() {
    if (name.trim().length() == 0)
      // Switch to game over on empty name
      stateManager.switchState(stateManager.gameOverState);
    else {
      // Save highscore and switch to game over
      highscoreLeaderboard.addHighscore(gameController.score, name);
      stateManager.switchState(stateManager.gameOverState);
    }
  }
}

//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: GameStateFinished, used to display GameOver Graphics
//  Implements: GameState
//******************************************************************************
public class GameStateFinished implements GameState {
 
  PVector uiPosition;       // Position of ui
  BlinkingText restartText; // "Press any key to restart!" blinker
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void run() {
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void enter() {
    // Reset state on enter
    uiPosition = new PVector((width / 2), (height / 2) - 120);
    
    // Set highscore leaderboard position
    highscoreLeaderboard.setPosition(new PVector(uiPosition.x - 145, uiPosition.y));
    
    // Blinking restart game text
    restartText = new BlinkingText(2, 1, "Press any key to restart!", 
      content.fontSizeSubtitle, new PVector(uiPosition.x - 170, uiPosition.y + 300)); 
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void exit() {
    // Reset game controller
    gameController.reset();
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void drawDisplay() {
    // Draw "GAMEOVER" title
    textSize(content.fontSizeTitle);
    text("GAMEOVER", uiPosition.x - 115, uiPosition.y - 90);
    
    // Setup score subtitle
    textSize(content.fontSizeSubtitle);
    String scoreString = "Score: " + String.valueOf(gameController.score);
    
    // Display Score
    text(scoreString, uiPosition.x + 5 - scoreString.length() * 7.5f, uiPosition.y - 60);
    
    // Display High scores
    highscoreLeaderboard.display();
    
    // Display Restart subtitle
    restartText.draw();
  }
  
  //****************************************************************************
  //  Summary: Interface method, see GameState for details
  //****************************************************************************
  public void handleInput() {
    // On any input switch to game state
    stateManager.switchState(stateManager.runningState);
  }
}
//****************************************************************************** //<>//
//  Author: Scott Crooks
//
//  Usage: Helper class, stores transform information.
//         E.g. Position and Size of transform (for collision)
//******************************************************************************
public class Transform {

  private PVector position; // Position of this transform
  private float width;      // Width of this transform
  private float height;     // Height of this transform

  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public Transform() {
    position = new PVector(0, 0);
    this.width = 0;
    this.height = 0;
  }

  //****************************************************************************
  //  Summary: Constructor
  //  Params: position - Position of this transform
  //          size - Size of transform
  //****************************************************************************
  public Transform(PVector position, PVector size) {
    this.position = position;
    this.width = size.x;
    this.height = size.y;
  }

  //****************************************************************************
  //  Summary: Constructor
  //  Params: position - Position of this transform
  //          width - Width of this transform
  //          height - Height of this transform
  //****************************************************************************
  public Transform(PVector position, float width, float height) {
    this.position = position;
    this.width = width;
    this.height = height;
  }

  //****************************************************************************
  //  Summary: Check if a collision has occured between this transform and
  //           specified transform
  //  Params: transform - Transform we are checking for collision with
  //  Return: Boolean - True if a collision has occured
  //****************************************************************************
  public boolean hasCollisionOccured(Transform transform) {
    return Collision.boxCollision(this, transform);
  }

  //****************************************************************************
  //  Summary: Finds the center of this transform
  //  Return: PVector - The position at the center of this transform
  //****************************************************************************
  public PVector getCenter() {
    return new PVector(this.width/2, this.height/2).add(position);
  }

  //****************************************************************************
  //  Summary: Getter for transform position
  //  Return: PVector - The position of this transform
  //****************************************************************************
  public PVector getPosition() {
    return this.position;
  }

  //****************************************************************************
  //  Summary: Setter for transform position
  //  Params: position - New position for transform
  //****************************************************************************
  public void setPosition(PVector position) {
    this.position = position;
  }

  //****************************************************************************
  //  Summary: Getter for transform width
  //  Return: float - Width of this transform
  //****************************************************************************
  public float getWidth() {
    return this.width;
  }

  //****************************************************************************
  //  Summary: Getter for transform height
  //  Return: float - Height of this transform
  //****************************************************************************
  public float getHeight() {
    return this.height;
  }
  
  //****************************************************************************
  //  Summary: Get width and height of transform as PVector
  //  Return: PVector - size of this transform
  //****************************************************************************
  public PVector getSize() {
    return new PVector(this.width, this.height);
  }
}


//******************************************************************************
//  Author: Scott Crooks, Andrew McKenzie, Robert Preston
//
//  Usage: Static Helper class, used for checking collisions between Transforms
//******************************************************************************
public static class Collision {

  //****************************************************************************
  //  Summary: Performs a box collision check between two Transforms
  //  Params: transformOne - First transform for collision
  //          transformTwo - Secondary transform for collision
  //  Return: boolean - Has a collision occured between provided transform
  //****************************************************************************
  public static boolean boxCollision(Transform transformOne, Transform transformTwo) {
    // Cache data
    PVector posOne = transformOne.position;
    PVector posTwo = transformTwo.position;

    // Check if colliding starting from top left of box
    if (posOne.x > posTwo.x
      && posOne.x < posTwo.x + transformTwo.width
      && posOne.y > posTwo.y
      && posOne.y < posTwo.y + transformTwo.height) {
      return true;
    }

    return false;
  }

  //****************************************************************************
  //  Summary: Performs a circle collision check between two Transforms
  //  Params: transformOne - First transform for collision
  //          transformTwo - Secondary transform for collision
  //  Return: boolean - Has a collision occured between provided transform
  //****************************************************************************
  public static boolean circleCollision(Transform colOne, Transform colTwo) {
    // Cache data
    PVector posOne =  colOne.getCenter();
    PVector posTwo = colTwo.getCenter();

    // Get the average of the width and the height for a rough radius.
    float radiusOne = (colOne.width / 2 + colOne.height / 2) / 2;
    float radiusTwo = (colTwo.width / 2 + colTwo.height / 2) / 2;

    // Get the distance between the two radii
    float distance = posOne.dist(posTwo);

    // Check for the actual collision by comparing the distance between
    // the two transforms and the sizes of the radii
    if (distance < (radiusOne + radiusTwo))
      return true;

    // If a collision hasn't occured return false
    return false;
  }

  //****************************************************************************
  //  Summary: Checks if a collision has occured between a circle and an
  //           axis-aligned rectangle.
  //  Params: position - The position of the circle
  //          radius - The radius of the circle
  //          transform - The rectangle for the calculation
  //  Return: boolean - Has a collision occured between the circle and square?
  //****************************************************************************
  public static boolean circleSquareCollision(PVector position, float radius, Transform transform) {
    // Get the absolute distance between the center of the circle and the center of the rect
    PVector circleDist = new PVector(abs(position.x - transform.getCenter().x),
      abs(position.y - transform.getCenter().y));

    // If the distance between the circle and the square is than sum
    // of their parts there is no need to go further and we can return false.
    if (circleDist.x > (transform.getWidth() / 2 + radius))
      return false;
    if (circleDist.y > (transform.getHeight() / 2 + radius))
      return false;

    // Is the cirle close enough to the rect that a collision is guaranteed?
    if (circleDist.x <= (transform.getWidth() / 2))
      return true;
    if (circleDist.y <= (transform.getHeight() / 2))
      return true;

    // Compute the distance from the corner to the circle
    float cornerDistanceSq = (float)(Math.pow((circleDist.x - transform.getWidth() / 2), 2)
      + Math.pow((circleDist.y - transform.getHeight() / 2), 2));

    // is the distance from the corner less then the radius of the circle?
    return cornerDistanceSq <= Math.pow(radius, 2);
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Helper class for handling time and deltaTime
//
//  Info: DeltaTime is the time in miliseconds since the last frame. Useful for
//        disconnecting time based logic from fps (Frames per second).
//        E.g. Movement or timers
//******************************************************************************
public class Time {
  private int deltaTime; // Time since last frame (milliseconds)
  private int lastTime;  // Total time in milliseconds since the program started

  private float timeMultiplier; // Used for speeding up/slowning down game
  private float defaultSpeed;   // Default speed
  private float minSpeed;       // Minimum game speed
  private float maxSpeed;       // Maximum game speed

  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public Time() {
    // Set times to zero
    deltaTime = 0;
    lastTime = 0;

    // Set default speed multiplier settings
    defaultSpeed = 1;
    timeMultiplier = 1;
    minSpeed = 0.2f;
    maxSpeed = 5;
  }

  //****************************************************************************
  //  Summary: MUST run once every frame to calculate time since last frame
  //           Calculates the deltaTime,
  //           E.g. time since this function was last called (once a frame)
  //****************************************************************************
  public void calcDeltaTime() {
    // Calculate the deltaTime by subtracting the total time last frame from
    // the total time in milliseconds this frame
    deltaTime = millis() - lastTime;

    // Set last time to the result of millis
    lastTime = millis();

    // Multiply deltaTime by time multiplier
    deltaTime *= timeMultiplier;
  }

  //****************************************************************************
  //  Summary: Getter for deltaTime
  //  Return: int - Time in milliseconds since last frame
  //****************************************************************************
  public int getDeltaTime() {
    return this.deltaTime;
  }

  //****************************************************************************
  //  Summary: Getter for deltaTime in seconds
  //  Return: float - Time in seconds since last frame
  //****************************************************************************
  public float getDeltaTimeSeconds() {
    return (float)deltaTime / 1000;
  }

  //****************************************************************************
  //  Summary: Increase the time multiplier
  //  Params: increase - what to increase the speed multiplier by
  //****************************************************************************
  public void increaseSpeed(float increase) {
    // If increase isn't positive return
    if (increase < 0) return;

    // If the speed increase + time multiplier is greater then the allowed
    // maximum speed set the speed to maxSpeed. Otherwise increase the
    // speed multiplier by the requested increase.
    if (timeMultiplier + increase < maxSpeed)
      timeMultiplier += increase;
    else
      timeMultiplier = maxSpeed;
  }

  //****************************************************************************
  //  Summary: decrease the time multiplier
  //  Params: decrease - what to decrease the speed multiplier by
  //****************************************************************************
  public void decreaseSpeed(float decrease) {
    // If increase isn't positive return
    if (decrease < 0) return;

    // If the speed decrease - time multiplier is smaller then minSpeed, set the
    // speed multiplier to minSpeed. Otherwise decrease the time multiplier by
    // requested cecrease.
    if (timeMultiplier - decrease > minSpeed)
      timeMultiplier -= decrease;
    else
      timeMultiplier = minSpeed;
  }

  //****************************************************************************
  //  Summary: set the speed multiplier to requested speed
  //  Params: speed - what to set the speed multiplier to
  //****************************************************************************
  public void setSpeedMultiplier(float speed) {

    // Clamp speed to maxSpeed and minSpeed.
    if (speed > maxSpeed)
      timeMultiplier = maxSpeed;
    else if (speed < minSpeed)
      timeMultiplier = minSpeed;
    else
      timeMultiplier = speed;
  }

  //****************************************************************************
  //  Summary: Reset speed multiplier to default speed
  //****************************************************************************
  public void resetSpeedMultiplier() {
    timeMultiplier = defaultSpeed;
  }
}


//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Utility class for handling blinking text
//******************************************************************************
public class BlinkingText {

  float onInterval;      // Blink on interval
  float offInterval;     // Blink off interval
  float currentInterval; // Current blink seconds elapsed
  boolean visible;       // Currently visible?
  String text;           // Text to display
  float fontSize;        // Font size
  PVector position;      // Position

  //****************************************************************************
  //  Summary: Constructor
  //  Params: interval - The blinking delay
  //          text - Text to display
  //          fontSize - Font size of text
  //          position - Position of blinking text
  //****************************************************************************
  public BlinkingText(float interval, String text, float fontSize, PVector position) {
    this.onInterval = interval;
    this.offInterval = interval;
    this.text = text;
    this.fontSize = fontSize;
    this.currentInterval = 0;
    this.visible = true;
    this.position = position;
  }

  //****************************************************************************
  //  Summary: Alternate Constructor for non-even blinking.
  //           E.g. OnInterval may be longer than OffInterval
  //  Params: onInterval - The blinking delay while on
  //          offInterval - The blinking delay while off
  //          text - Text to display
  //          fontSize - Font size of text
  //          position - Position of blinking text
  //****************************************************************************
  public BlinkingText(float onInterval, float offInterval, String text, float fontSize, PVector position) {
    this.onInterval = onInterval;
    this.offInterval = offInterval;
    this.text = text;
    this.fontSize = fontSize;
    this.currentInterval = 0;
    this.visible = true;
    this.position = position;
  }

  //****************************************************************************
  //  Summary: Every frame draw the text to screen and calculate blink interval
  //****************************************************************************
  public void draw() {
    // Increase the interval by the time in seconds since the last fame
    currentInterval += time.getDeltaTimeSeconds();

    // If the test is visible track on interval, otherwise track off interval
    if (visible) {
      if (currentInterval > onInterval) {
        currentInterval = 0;
        visible = false;
      }
    } else {
      if (currentInterval > offInterval) {
        currentInterval = 0;
        visible = true;
      }
    }

    // If text is visible display the text
    if (visible) {
      textSize(fontSize);
      text(text, position.x, position.y);
    }
  }
}

//******************************************************************************
//  Authors: Scott Crooks
//
//  Usage: Highscore display, displays highscores, saves highscores
//         and reads highscores
//******************************************************************************
public class HighscoreLeaderboard {

  // Variables
  PVector position;  // Position of highscore display

  //****************************************************************************
  //  Summary: Constructor
  //****************************************************************************
  public HighscoreLeaderboard() {
    position = new PVector(0, 0);
  }

  //****************************************************************************
  //  Summary: Draws highscore to screen
  //****************************************************************************
  public void display() {
    // Title
    textSize(content.fontSizeSubtitle);
    text("HIGHSCORES:", position.x + 60, position.y);

    // Subtitle
    textSize(content.fontSizeSubtitle);
    text("USER", position.x + 30, content.fontSizeSubtitle + position.y);
    text("SCORE", position.x + 190, content.fontSizeSubtitle + position.y);

    // Reset position offset
    float scoreOffsetY = 55;

    // Draw scores to screen
    textSize(content.fontSizeSubtitle);
    for (Score score : content.getHighscores()) {
      // Draw User and respective score to screen
      text(score.name, position.x + 30, position.y + scoreOffsetY);
      text(String.valueOf(score.score), position.x + 190, position.y + scoreOffsetY);

      // Increase score offset so following score doesn't draw over existing score
      scoreOffsetY += 20;
    }
  }

  //****************************************************************************
  // Summary: Checks if score is greater than an existing highscore.
  // Params: score - Score to compare against highscore list.
  // Return: Boolean - Is the score a new highscore
  //****************************************************************************
  public boolean newHighscore(int score) {
    for (Score highscore : content.getHighscores()) {
      if (score > highscore.score)
        return true;
    }

    return false;
  }

  //****************************************************************************
  // Summary: Adds a new highscore to the highscore list
  // Params: score - Score of new highscorer
  //         name - Username of new highscorer
  //****************************************************************************
  public void addHighscore(int score, String name) {
    // Create copy of highscore list
    List<Score> highscores = content.getHighscores();

    // Clean name
    name.trim();

    // Add new highscore to list
    highscores.add(new Score(name, score));

    // Insert new highscore into list at correct position
    for (int i = highscores.size() - 1; i > 0; i--) {
      if (highscores.get(i).score > highscores.get(i - 1).score) {
        Collections.swap(highscores, i, i - 1);
      }
    }

    // Send new highscore list to content class
    content.setHighscores(highscores);
  }

  //****************************************************************************
  // Summary: setter for display position
  // Params: position - Where to display highscore leaderboard
  //****************************************************************************
  public void setPosition(PVector position) {
    this.position = position;
  }
}
//******************************************************************************
//  Visual
//
//  [Original] Author: Robert Preston
//
//  Usage: Reusable Visual code
//
//  Changelog:
//    * 18 May -- Created Visual
//******************************************************************************
public class Trail {

  private ArrayList<PVector> segmentPositions; // An array to store the positions of trail segments.
  private int alpha = 200;          // Trail alpha, used for fading out the trail
  public Boolean destroyed = false; // Is the trail destroyed?

  //****************************************************************************
  //  Summary: Trail constructor
  //****************************************************************************
  public Trail() {
    segmentPositions = new ArrayList<PVector>();
  }

  //****************************************************************************
  //  Summary: Add a new segnment to the trail
  //  Params: position - PVector of the new segment
  //****************************************************************************
  public void addSegment(PVector position) {
    segmentPositions.add(position);
  }

  //****************************************************************************
  //  Summary: Draw the trail to the screen
  //****************************************************************************
  public void draw() {

    // If the missile is destroyed start fading out the trail
    if (destroyed)
      alpha -= 5;

    // If the trail alpha is less then 0 we can destroy the trail
    if (alpha < 0)
      gameController.trails.remove(this);

    // Begin drawing trail
    strokeWeight(1);
    noFill();
    stroke(255, alpha);
    beginShape();
    
    for (int i = 0; i < segmentPositions.size(); i++)
      // For each segment position create a vertex at point
      curveVertex(segmentPositions.get(i).x, segmentPositions.get(i).y);

    // Finish trail
    endShape();
  }
}

//********************************************************************************
//  Authors: Robert Preston
//
//  Usage: Creates a missile explosion and controls graphics
//********************************************************************************
public class Explosion {
  
  public final boolean friendly; // Is this a friendly explosion?
  public final float radius;     // Explosion radius
  public final float diameter;   // Explosion diameter
  public final PVector center;   // position of explosion
  public int lifespan = 255;     // Duration of explosion vfx
  public boolean exploded;       // Should we continue to destroy enemies in explosion
  
  //******************************************************************************
  //  Summary: Constructor for the MissileExplosion
  //  Params: center - PVector for the center of the explosion
  //          diameter - Float for the diameter of the explosion
  //          friendly - Is this a friendly explosion?
  //******************************************************************************
  public Explosion(PVector center, float diameter, boolean friendly) {
    this.friendly = friendly;
    this.radius = diameter / 2;
    this.diameter = diameter;
    this.center = center;
    this.lifespan = 255;
    this.exploded = false;
  }

  //******************************************************************************
  //  Summary: Call AI and draw the explosion.
  //******************************************************************************
  public void draw() {
    ai();
    ellipseMode(CORNER);
    fill(255, lifespan);
    noStroke();
    ellipse(center.x - diameter / 2, center.y - diameter / 2, diameter, diameter);
  }

  //******************************************************************************
  //  Summary: Update explosion properties.
  //******************************************************************************
  public void ai() {
    lifespan -= 10;
  }
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
